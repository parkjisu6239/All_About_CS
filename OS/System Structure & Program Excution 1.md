# System Structure & Program Execution 1

![img](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F983114eb-04d1-4a12-837c-9a0e523cadcc%2FUntitled.png?table=block&id=b1d96e70-fe58-480b-815b-e966a4450740&spaceId=71e505f8-112e-48f9-9496-223cedb10167&width=1730&userId=6c8d8012-ae13-4a3f-9ebf-b94e978a51fe&cache=v2)

### CPU - Memory - IO

CPU는 메모리의 데이터에만 접근한다. 디스크에 있는 데이터에 접근하거나, 입출력을 읽어올때는 각 입출력 디바이스의 디바이스 컨트롤러에 일을 위임한다. 또한 사용자 프로그램은 입출력 장치에 직접 접근할 수 없기 때문에, 입출력이 필요한 경우 갖고있던 CPU 제어권을 운영체제에 넘긴다. 이러한 작업은 CPU에 비해 느리기 때문에, 그 일을 시켜 놓은 후 CPU는 쉬지 않고 메모리에 적재된 다른 프로세스의 일을 처리한다. 그러다 디스크 컨트롤러에서 작업이 끝나면 인터럽트를 발생시켜 CPU의 제어권을 얻게 된다.



### Device Controller

- 해당 입출력 장치 유형을 관리하는 일종의 작은 CPU
- 제어 정보를 위해 control register, status register를 가짐
- local buffer를 가짐(일종의 data register)

입출력은 실제 디바이스와 로컬 버퍼 사이에서 일어나며, 입출력이 끝났을 때 인터럽트를 발생시킨다.

참고, Device driver(장치 구동기)는 OS 코드 중 장치별 처리 루틴으로 소프트웨어이다. 운영체제가 디바이스 컨트롤러에 일을 시키기 위한 코드를 갖고 있다.



### Timer

- 타이머는 시분할 방식에서 CPU 제어권을 다른 프로세스로 옮기기 위한 역할을 한다.
- CPU는 인스트럭션을 잘 진행하고 있고, 타이머에 설정된 시간이 지나면 인터럽트를 발생시킨다.
- CPU는 인스트럭션을 하나 실행할때마다 인터럽트 라인을 확인하는데, 이때 인터럽트가 있으면 다른 프로세스를 실행한다.
- 타이머는 매 클럭 틱 때마다 1씩 감소하고 0 이 되면 인터럽트를 발생시킨다.



### Mode bit

- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치
- mode bit는 0 또는 1의 값을 가진다. 0일때는 운영체제가 CPU를 가지고 있다는 뜻으로, 모든 인스트럭션이 가능하다. `모니터 모드`, `커널 모드`라고 하기도 하며 `특권명령`등을 실행할 수 있다
- 1일 때는 사용자 프로그램이 제어권을 가지고 있다는 뜻으로, 일부 인스트럭션은 제한되어 있다(입출력 같은 것). `일반 명령`을 실행한다.
- 인터럽트나 Exception이 발생하면 제어권이 운영체제로 바뀌게 되며, mode bit이 0이 된다. 반대로 사용자 프로그램에 CPU를 넘기기 전에 mode bit을 1로 바꾼다.



### I / O

- 모든 입출력 명령은 특권 명령
- 사용자 프로그램은 어떻게 IO를 하는가?
  - 시스템 콜 : 사용자 프로그램에서 입출력이 필요한 경우, 인터럽트를 발생시켜서 운영체제로 제어권을 넘기는 것
  - trap(사용자 프로그램이 발생시킨 인터럽트)을 사용하여 인터럽트 벡터의 특정 위치로 이동
  - 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
  - 올바른 IO요청인지 확인 후 IO수행
  - IO완료 시 제어권을 시스템 콜로 다음 명령으로 옮김



### 인터럽트

- 인터럽트를 당한 시점의 레지스터와 PC를 저장한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.
- 인터럽트의 종류
  - Interrupt(하드웨어 인터럽트) : 하드웨어(입출력 장치 등)가 발생시킨 인터럽트
  - Trap(소프트웨어 인터럽트)
    - Exception : 프로그램이 오류를 범한 경우(0으로 나눈 것등)
    - System call : 프로그램이 커널 함수를 호출하는 경우(시스템 프로그램이 입출력하려는 경우)
- 인터럽트 관련 용어
  - 인터럽트 벡터 : 해당 인터럽트의 처리 루틴 주소를 가지고 있음
  - 인터럽트 처리 루틴(Interrupt Service Routine, 인터럽트 핸들러) : 해당 인터럽트를 처리하는 커널 함수



### DMA controller(Direct Memory Access)

- 입출력 요청등 빈번한 인터럽트로 CPU가 과도하게 방해받고, 효율성이 떨어지는 문제를 해결하기 위한 장치
- 디바이스 컨트롤러에서 입출력이 완료된 작업 결과물(디스크에서 읽어온 값등)을 CPU를 대신하여 메모리에 적재하는 역할
- CPU와 DMA controller가 동시에 메모리에 접근하여 발생하는 문제를 해결하기 위해 Memory controller가 이를 중재한다.



### 컴퓨터의 동작 방식

위 사진처럼 사용자 프로그램 A, B가 있고, Timer는 100ms로 설정된다고 하자.

1. 사용자 프로그램 A가 CPU의 제어권을 가지고 있다.
2. 사용자 프로그램 A가 아직 종료되지 않았지만, 100ms가 지나서 제어권을 프로그램 B에 넘긴다.
3. 프로그램 B가 실행 되던중, 디스크를 읽어와야 하는 인스트럭션이 실행된다. (트랩)
4. 입출력 장치에 접근하기 위해 프로그램 B가 제어권을 운영체제에 넘긴다. (모드 비트 1 → 0)
5. 운영체제가 디스크의 디바이스 컨트롤러에 값을 읽어오라고 시키고, 디스크는 헤드를 움직이며 찾는다.
6. 다시 CPU 제어권이 B로 넘어오지만, 디바이스에서 데이터를 읽지 않으면 실행할 수 없는 작업이므로, 제어권을 A로 넘긴다. (모드비트 0 → 1)
7. A가 제어권을 할당받아 열심히 실행된다.
8. 그러던 중 디스크 읽기 작업이 완료되어, 디스크 로컬버퍼에 데이터가 담기고 CPU에 인터럽트를 발생시킨다. (인터럽트)
9. A를 실행하던 CPU가 인터럽트 라인을 읽고, 운영체제에 CPU 제어권을 할당한 후 디스크에서 값을 받아 온다. (모드 비트 1 → 0)
10. 다시 제어권을 A가 받고, 100ms 를 모두 실행한 후 B에 제어권을 넘긴다.
11. B는 좀 전에 읽어온 디스크 데이터를 가지고 원래 하려던 작업을 실행한다.







____

**Reference**

- https://core.ewha.ac.kr/publicview/C0101020140311132925816476?vmode=f